import { useEffect, useRef, useState } from "react";
import {getMinimaxMove, isBoardFull, getWinner} from "../controllers/Minimax.js";
import { useTyping } from "../hooks/useTyping";
import midFile from "../data/TicTacToeAIMid.txt";
import startFile from "../data/TicTacToeAIStart.txt";
import drawFile from "../data/TicTacToeAIDraw.txt";
import winFile from "../data/TicTacToeAIWin.txt";


/**
 * A custom hook that manages the state and logic of a Tic Tac Toe game.
 * @returns {Object} An object containing the current board, functions to start the game and make a player move, 
 * a boolean indicating if it's the player's turn, a boolean indicating if the game is over, the winner of the game, 
 * and a sentence generated by the AI.
 */
export function useTicTacToe() {

    // Set up initial state
    const initialBoard = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
    ]
    const [board, setBoard] = useState(initialBoard);
    const [isPlayerTurn, setIsPlayerTurn] = useState(true);
    const [isGameOver, setIsGameOver] = useState(false);
    const [winner, setWinner] = useState(null);
    const [aiSentence, setAiSentence] = useState("");
    const boardRef = useRef(board);
    const [midGameSentences, setMidGameSentences] = useState([]);
    const [startSentences, setStartSentences] = useState([]);
    const [drawSentences, setDrawSentences] = useState([]);
    const [winSentences, setWinSentences] = useState([]);
    const thinkingTime = 2000;

    // Rest of the code

    /**
     * Fetches sentences from text files and sets them in state.
     */
    async function getSentences() {
        const midSentences = await readFileAndExtractSentences(midFile);
        setMidGameSentences(midSentences);

        const startSentences = await readFileAndExtractSentences(startFile);
        setStartSentences(startSentences);

        const drawSentences = await readFileAndExtractSentences(drawFile);
        setDrawSentences(drawSentences);

        const winSentences = await readFileAndExtractSentences(winFile);
        setWinSentences(winSentences);

        setAiSentence(startSentences[Math.floor(Math.random() * startSentences.length)]);
    }

    /**
     * Reads a text file and extracts sentences from it.
     * @param {string} fileName - The name of the file to read.
     * @returns {Array} An array of sentences extracted from the file.
     */
    const readFileAndExtractSentences = async (fileName) => {
        try {
          const response = await fetch(fileName);
          const text = await response.text();
          const sentencesArray = text.split("\n");
          return sentencesArray.filter(sentence => sentence.trim() !== '');
        } catch (error) {
          console.error('Error reading the text file:', error);
          return [];
        }
    };

    // Set up effects
    useEffect(() => {
        getSentences();
    }, []);

    useEffect(() => {
        boardRef.current = board;

        // check if board all 0 (empty)
        if (board.every(row => row.every(cell => cell === 0))) return;
        if (isGameOver) return;

        if (isPlayerTurn) {
            checkEndGame(1);
        }
        else {
            checkEndGame(2);
        }

    }, [board]);

    /**
     * Resets the game to its initial state.
     */
    function startGame() {
        setBoard(initialBoard);
        setIsGameOver(false);
        setWinner(null);
        setIsPlayerTurn(true);
        setAiSentence(startSentences[Math.floor(Math.random() * startSentences.length)]);
    }

    /**
     * Handles the player's move and updates the board accordingly.
     * @param {number} row - The row index of the cell the player chose.
     * @param {number} col - The column index of the cell the player chose.
     */
    async function playerChose(row, col) {
        if (boardRef.current[row][col] !== 0) return;
        setMove(row, col, 1);
    }

    /**
     * Calculates the computer's move using the minimax algorithm and updates the board accordingly.
     */
    async function getComputerMove() {
        const {row, col} = getMinimaxMove(boardRef.current);
        setAiSentence(midGameSentences[Math.floor(Math.random() * midGameSentences.length)]);
        await new Promise(r => setTimeout(r, thinkingTime));
        setMove(row, col, 2);
    }

    /**
     * Checks if the game has ended and updates the state accordingly.
     * @param {number} player - The player who made the last move.
     */
    function checkEndGame(player) {
        const winner = getWinner(boardRef.current, true);
        if(winner !== null) {
            setIsGameOver(true);
            setWinner(winner);
            if (winner === 2) {
                setAiSentence(winSentences[Math.floor(Math.random() * winSentences.length)]);
            }
        }
        else if (isBoardFull(boardRef.current)) {
            setIsGameOver(true);
            setWinner(0);
            setAiSentence(drawSentences[Math.floor(Math.random() * drawSentences.length)]);
        }
        else {
            if (player === 1) {
                setIsPlayerTurn(false);
                getComputerMove();
            }
            else {
                setIsPlayerTurn(true);
            }
        }
    }

    /**
     * Updates the board with the player's or computer's move.
     * @param {number} row - The row index of the cell to update.
     * @param {number} col - The column index of the cell to update.
     * @param {number} player - The player who made the move.
     */
    async function setMove(row, col, player) {
        const newBoard = boardRef.current.map(row => [...row]);
        newBoard[row][col] = player;
        await setBoard(newBoard);
    }

    // Return state and functions
    return {board, startGame , playerChose, isPlayerTurn, isGameOver, winner, aiSentence};
}
